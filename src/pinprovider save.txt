import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

export interface CodePin {
  id: string;
  file: string;
  line: number | [number, number];
  title: string;
  color?: string;
  parentFolderId?: string | null;
  type?: 'team' | 'local';
  note?: string;
}

export interface CodePinFolder {
  id: string;
  title: string;
  color?: string;
  type?: 'team' | 'local';
  order?: number;
}

export class PinProvider implements vscode.TreeDataProvider<PinItem>, vscode.TreeDragAndDropController<PinItem> {
  dropMimeTypes = ['application/vnd.codepin.treeitem'];
  dragMimeTypes = ['application/vnd.codepin.treeitem'];

  teamFile: string;
  localFile: string;

  public teamPins: CodePin[] = [];
  public teamFolders: CodePinFolder[] = [];
  public localPins: CodePin[] = [];
  public localFolders: CodePinFolder[] = [];


  private _onDidChangeTreeData: vscode.EventEmitter<PinItem | undefined | void> = new vscode.EventEmitter<PinItem | undefined | void>();
  readonly onDidChangeTreeData: vscode.Event<PinItem | undefined | void> = this._onDidChangeTreeData.event;

  public pins: CodePin[] = [];
  public folders: CodePinFolder[] = [];

  constructor(private workspaceRoot: string, private extensionContext: vscode.ExtensionContext) {
    const pinFile = path.join(this.workspaceRoot, '.codepin.json');
    this.teamFile = path.join(this.workspaceRoot, '.codepin.team.json');
    this.localFile = path.join(this.workspaceRoot, '.codepin.local.json');
    this.loadData();
    if (fs.existsSync(pinFile)) {
      try {
        const data = JSON.parse(fs.readFileSync(pinFile, 'utf8'));
        this.pins = data.pins || [];
        this.folders = data.folders || [];
      } catch {
        this.pins = [];
        this.folders = [];
      }
    }
  }

  refresh(): void {
    this.loadData();
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: PinItem): vscode.TreeItem {
    return element;
  }

  loadData() {

  if (fs.existsSync(this.teamFile)) {
    try {
      const data = JSON.parse(fs.readFileSync(this.teamFile, 'utf8'));
      this.teamPins = (data.pins || []).map(p => ({ ...p, type: 'team' }));
      this.teamFolders = (data.folders || []).map(f => ({ ...f, type: 'team' }));
    } catch {
      this.teamPins = [];
      this.teamFolders = [];
    }
  } else {
    this.teamPins = [];
    this.teamFolders = [];
  }

  if (fs.existsSync(this.localFile)) {
    try {
      const data = JSON.parse(fs.readFileSync(this.localFile, 'utf8'));
      this.localPins = (data.pins || []).map(p => ({ ...p, type: 'local' }));
      this.localFolders = (data.folders || []).map(f => ({ ...f, type: 'local' }));
    } catch {
      this.localPins = [];
      this.localFolders = [];
    }
  } else {
    this.localPins = [];
    this.localFolders = [];
  }
}


  async getChildren(element?: PinItem): Promise<PinItem[]> {

    const pinFile = path.join(this.workspaceRoot, '.codepin.json');
    let pins: CodePin[] = [];
    let folders: CodePinFolder[] = [];
    if (fs.existsSync(pinFile)) {
      try {
        const data = JSON.parse(fs.readFileSync(pinFile, 'utf8'));
        pins = data.pins || [];
        folders = data.folders || [];
      } catch {
        pins = [];
        folders = [];
      }
    }

    this.pins = pins;
    this.folders = folders;
    
    const openOnClick = vscode.workspace.getConfiguration('codepin').get('openPinOnClick', true);
    const showFullPath = vscode.workspace.getConfiguration('codepin').get('showFullPath', false);

    const colorToIcon: Record<string, string> = {
      blue: this.extensionContext.asAbsolutePath('resources/pin_blue.svg'),
      green: this.extensionContext.asAbsolutePath('resources/pin_green.svg'),
      purple: this.extensionContext.asAbsolutePath('resources/pin_purple.svg'),
      red: this.extensionContext.asAbsolutePath('resources/pin_red.svg'),
      yellow: this.extensionContext.asAbsolutePath('resources/pin_yellow.svg'),
      orange: this.extensionContext.asAbsolutePath('resources/pin_orange.svg'),
      brown: this.extensionContext.asAbsolutePath('resources/pin_brown.svg'),
      black: this.extensionContext.asAbsolutePath('resources/pin_black.svg'),
      white: this.extensionContext.asAbsolutePath('resources/pin_white.svg'),
    };

    const colorToFolderIcon: Record<string, string> = {
      blue: this.extensionContext.asAbsolutePath('resources/folder_blue.svg'),
      green: this.extensionContext.asAbsolutePath('resources/folder_green.svg'),
      purple: this.extensionContext.asAbsolutePath('resources/folder_purple.svg'),
      red: this.extensionContext.asAbsolutePath('resources/folder_red.svg'),
      yellow: this.extensionContext.asAbsolutePath('resources/folder_yellow.svg'),
      orange: this.extensionContext.asAbsolutePath('resources/folder_orange.svg'),
      brown: this.extensionContext.asAbsolutePath('resources/folder_brown.svg'),
      black: this.extensionContext.asAbsolutePath('resources/folder_black.svg'),
      white: this.extensionContext.asAbsolutePath('resources/folder_white.svg'),
    };

    if (!element) {
      const folders = this.folders
        .sort((a, b) => (a.order ?? 0) - (b.order ?? 0))
        .map(f => {
          const item = new PinItem(
            f.title,
            vscode.TreeItemCollapsibleState.Collapsed,
            undefined,
            f,
            true
          );
          const colorKey = f.color && colorToFolderIcon[f.color] ? f.color : 'blue';
          item.iconPath = colorToFolderIcon[colorKey];
          return item;
        });
      const rootPins = await Promise.all(
        this.pins
          .filter(p => !p.parentFolderId)
          .map(async pin => {
            const filePath = path.join(this.workspaceRoot, pin.file);
            let lineText = '';
            try {
              const doc = await vscode.workspace.openTextDocument(filePath);
              if (typeof pin.line === 'number' && pin.line < doc.lineCount) {
                lineText = doc.lineAt(pin.line).text.trim();
              } else if (
                Array.isArray(pin.line) &&
                pin.line[0] < doc.lineCount
              ) {
                lineText = doc.lineAt(pin.line[0]).text.trim();
              } else {
                lineText = '(Line missing)';
              }
            } catch {
              lineText = '(File missing)';
            }
            let label = pin.title;
            if (showFullPath) {
              label += ` (${pin.file}:${typeof pin.line === "number" ? pin.line + 1 : '?'})`;
            }
            const item = new PinItem(
              label,
              vscode.TreeItemCollapsibleState.None,
              pin,
              undefined,
              false
            );
            const colorKey = pin.color && colorToIcon[pin.color] ? pin.color : 'red';
            item.iconPath = colorToIcon[colorKey];
            item.tooltip = lineText || '(Line missing)';
            if (openOnClick){
              item.command = {
                command: 'codepin.openPin',
                title: 'Open Pin',
                arguments: [pin]
              };
            }
            return item;
          })
      );
      return [...folders, ...rootPins];
    } else if (element.isFolder && element.folder) {
      const pinsInFolder = await Promise.all(
        this.pins
          .filter(p => p.parentFolderId === element.folder!.id)
          .map(async pin => {
            const filePath = path.join(this.workspaceRoot, pin.file);
            let lineText = '';
            try {
              const doc = await vscode.workspace.openTextDocument(filePath);
              if (typeof pin.line === 'number' && pin.line < doc.lineCount) {
                lineText = doc.lineAt(pin.line).text.trim();
              } else if (
                Array.isArray(pin.line) &&
                pin.line[0] < doc.lineCount
              ) {
                lineText = doc.lineAt(pin.line[0]).text.trim();
              } else {
                lineText = '(Line missing)';
              }
            } catch {
              lineText = '(File missing)';
            }
            let label = pin.title;
            if (showFullPath) {
              label += ` (${pin.file}:${typeof pin.line === "number" ? pin.line + 1 : '?'})`;
            }
            const item = new PinItem(
              label,
              vscode.TreeItemCollapsibleState.None,
              pin,
              undefined,
              false
            );
            const colorKey = pin.color && colorToIcon[pin.color] ? pin.color : 'red';
            item.iconPath = colorToIcon[colorKey];
            item.tooltip = lineText || '(Line missing)';
            if (openOnClick){
              item.command = {
                command: 'codepin.openPin',
                title: 'Open Pin',
                arguments: [pin]
              };
            }
            return item;
          })
      );
      return pinsInFolder;
    }
    return [];
  }


  getPinById(id: string): CodePin | undefined {
    return this.pins.find(pin => pin.id === id);
  }

  getFolderById(id: string): CodePinFolder | undefined {
    return this.folders.find(folder => folder.id === id);
  }

  movePinRelativeToPin(movedPin: CodePin, targetPin: CodePin) {
    if (movedPin.parentFolderId !== targetPin.parentFolderId) return;

    const parentId = movedPin.parentFolderId || null;
    const pinsInParent = this.pins.filter(
      p => (p.parentFolderId || null) === parentId
    );
    const withoutMoved = pinsInParent.filter(p => p.id !== movedPin.id);
    const idx = withoutMoved.findIndex(p => p.id === targetPin.id);
    withoutMoved.splice(idx + 1, 0, movedPin);

    this.pins = [
      ...this.pins.filter(p => (p.parentFolderId || null) !== parentId),
      ...withoutMoved,
    ];
  }

  moveFolderRelativeToFolder(movedFolder: CodePinFolder, targetFolder: CodePinFolder) {
    const withoutMoved = this.folders.filter(f => f.id !== movedFolder.id);
    const idx = withoutMoved.findIndex(f => f.id === targetFolder.id);
    withoutMoved.splice(idx + 1, 0, movedFolder);
    this.folders = withoutMoved;
    this.folders.forEach((folder, idx) => {
    folder.order = idx;
  });
  }

  savePinsAndFolders() {
    const pinFile = path.join(this.workspaceRoot, '.codepin.json');
    const data = {
      pins: this.pins,
      folders: this.folders,
    };
    fs.writeFileSync(pinFile, JSON.stringify(data, null, 2), 'utf8');
  }

  async handleDrag(source: readonly PinItem[], dataTransfer: vscode.DataTransfer, token: vscode.CancellationToken) {
    const ids = source.map(item => item.id).join(',');
    dataTransfer.set('application/vnd.codepin.treeitem', new vscode.DataTransferItem(ids));
  }

  async handleDrop(target: PinItem | undefined, dataTransfer: vscode.DataTransfer, token: vscode.CancellationToken) {
    const ids = (await dataTransfer.get('application/vnd.codepin.treeitem')?.asString())?.split(',') ?? [];

    for (const draggedId of ids) {
      const draggedPin = this.getPinById(draggedId);
      const draggedFolder = this.getFolderById(draggedId);

      if (draggedPin) {
        if (target) {
          if (target.isFolder && target.folder) {
            draggedPin.parentFolderId = target.folder.id;
          } else if (target.pin && target.pin.parentFolderId === draggedPin.parentFolderId) {
            this.movePinRelativeToPin(draggedPin, target.pin);
          }
        } else {
          draggedPin.parentFolderId = null;
        }
      } else if (draggedFolder) {
        if (target && target.isFolder && target.folder) {
          this.moveFolderRelativeToFolder(draggedFolder, target.folder);
        }
      }
    }

    this.savePinsAndFolders();
    this.refresh();
  }
}

export class PinItem extends vscode.TreeItem {
  constructor(
    public readonly label: string,
    public readonly collapsibleState: vscode.TreeItemCollapsibleState,
    public readonly pin?: CodePin,
    public readonly folder?: CodePinFolder,
    public readonly isFolder: boolean = false
  ) {
    super(label, collapsibleState);
    this.contextValue = isFolder ? 'pinFolder' : 'pinItem';
    this.id = isFolder && folder ? folder.id : pin?.id || '';
  }
}
